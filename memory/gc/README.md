# Memory

[TOC]

## 3. gc

前面我们了解到，golang 编译器执行 escape analysis 后，根据需要数据可能被“搬”到堆内存上。

这里简单地介绍下 golang 的 gc，从而了解写 golang 代码时为什么应该尽量避免“额外的”内存分配。

### 3.1 Introduction

gc 是 go 语言非常重要的一部分，它大大简化了程序员写并发程序的复杂度。

人们发现写工作良好的并发程序似乎也不再是那少部分程序员的独有技能。

glang gc 使用一棵树来维护堆内存对象的引用，属于追踪式的 gc，它基于“标记-清除“算法工作，主要分为两个阶段：

1. 标记阶段 - 遍历所有堆内存对象，判断这些对象是否在用；
2. 清除阶段 - 遍历树，清除没有被引用的堆内存对象；

执行 gc 时，**golang 首先会执行一系列操作并停止应用程序的执行**，即 `stopping the world`，之后恢复应用程序的执行，同时 gc 其他相关的操作还会并行地执行。所以 golang 的 gc 也被称为 `concurrent mark-and-sweep`，这样做的目的是尽可能减少 `STW` 对程序运行的影响。

> 严格地说，`STW` 会发生两次，分别在标记开始和标记结束时。

golang gc 包括一个 `scavenger`，定期将不再使用的内存返还给操作系统。

> 也可以在程序中调用 `debug.FreeOSMemory()`，手动将内存返还给操作系统。

### 3.2 gc 触发机制

相比于 java，golang 提供的 gc 控制方式比较简单：通过环境变量 `GOGC` 来控制。

`GOGC`  定义了触发下次 gc 时堆内存的增长率，默认值为 100，即上次 gc 后，堆内存增长一倍时，触发另一次 gc。

例如，gc 触发时当前堆内存的大小时 128MB，如果 `GOGC=100`，那么当堆内存增长为 256MB时，执行下一次 gc。

另外，如果 golang 两分钟内没有执行过 gc，运行时会强制触发一次。

我们也可以在程序中调用 `runtime.GC()` 主动触发 gc。

```bash
# 通过设置环境变量 GODEBUG 可以显示 gc trace 信息

$ GODEBUG=gctrace=1 go test -bench=. -v

# 当 gc 运行时，相关信息会写到标准错误中
```

注意：为了减少 gc 触发次数而增加 `GOGC` 值并不一定能带来线性的收益，因为即便 gc 触发次数变少了，但是 gc 的执行可能会因为更大的堆内存而有所延长。在大多数情况下，`GOGC` 维持在默认值 100 即可。

### 3.3 gc hints

如果我们的代码中存在大量“额外”的堆内存分配，尤其是在代码关键路径上，对于性能的负面影响是非常大的：

- 首先，堆内存的分配本身就是相对耗时的操作
- 其次，大量“额外”的堆内存分配意味着额外的 gc 过程，STW 会进一步影响程序执行效率；

极端情况下，短时间内大量的堆内存分配，可能会直接触发 OOM，gc 甚至都没有执行的机会。

所以，不要“天真”的以为 gc 会帮你搞定所有的事情：你留给 gc 处理的工作越少，你的性能才会越“体面”。

从性能优化的角度，消除那些“额外的”内存分配收益十分明显，通常也会是第一或者第二优先的选项。

不得不使用堆内存时，可以考虑复用内存，例如通过 `sync.Pool` 来复用内存。

### 3.4 有了 gc 为什么还会有内存泄漏

即便 golang 是 gc 语言，它并不是一定没有内存泄漏，下面两种情况会导致内存泄漏的情况：

1. 引用堆内存对象的对象长期存在；
2. goroutine 需要消耗一定的内存来保存用户代码的上下文信息，goroutine 泄漏会导致内存泄漏；

### 3.5 代码演示

参考代码 `gc.go`：

- `allocator` 通过 channel 传送 `buf` 类型的结构体，`buf` 类型的结构体持有堆内存的引用；
- `mempool` 通过 channel 接收来自 `allocator` 的 buf，循环记录在 slice 中；
- `mempool` 定期打印应用当前内存状态，具体含义参考 [runtime.MemStats](https://pkg.go.dev/runtime@go1.20#MemStats)

```bash
$ go run gc.go
HeapSys(bytes),PoolSize(MiB),HeapAlloc(MiB),HeapInuse(MiB),HeapIdle(bytes),HeapReleased(bytes)
 12222464,     5.00,     7.11,     7.45,  4415488,  4300800
 16384000,    10.00,    12.11,    12.45,  3334144,  3153920
 24772608,    18.00,    20.11,    20.45,  3334144,  3121152
 28966912,    22.00,    24.11,    24.45,  3334144,  3121152
 33161216,    25.00,    27.11,    27.45,  4382720,  4169728
 37355520,    32.00,    34.11,    34.45,  1236992,   991232
 41549824,    36.00,    38.11,    38.45,  1236992,   991232
 54132736,    48.00,    50.11,    50.45,  1236992,   991232
 58327040,    51.00,    53.11,    53.45,  2285568,  2039808
```

如果程序中的变量持有对堆内存的引用，那么这块堆内存不会被 gc 回收。

对于引用了堆内存的变量，将其赋值给其他变量时，需要注意避免出现内存泄漏的情况。

将赋值有关的操作封装在方法中，通过合理的 API 设计可以避免出现“意想不到”内存泄露，参考 issue #370。

与内存有关的事情，介绍到这里，下面介绍下与 golang profiling 有关的事情。

### 3.6 参考资料

[GOGC on golang's document](https://pkg.go.dev/runtime@go1.20#hdr-Environment_Variables)

[GC 的认识](https://www.bookstack.cn/read/qcrao-Go-Questions/GC-GC.md)

